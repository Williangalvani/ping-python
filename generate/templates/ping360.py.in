#!/usr/bin/env python

# Ping1D.py
# A device API for the Blue Robotics Ping1D echosounder

# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
# THIS IS AN AUTOGENERATED FILE
# DO NOT EDIT
# ~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

from brping import pingmessage
import serial
import time
from device import PingDevice
import definitions

class Ping360(PingDevice):

{% for msg in messages["get"]|sort %}
    ##
    # @brief Get a {{msg|replace("get_", "")}} message from the device\n
    # Message description:\n
    # {{messages["get"][msg].description}}
    #
    # @return None if there is no reply from the device, otherwise a dictionary with the following keys:\n
{% for field in messages["get"][msg].payload %}
    # {{field.name}}: {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}\n
{% endfor%}
    def get_{{msg}}(self):
        if self.request(definitions.PING360_{{msg|upper}}) is None:
            return None
        data = ({
{% for field in messages["get"][msg].payload %}
            "{{field.name}}": self._{{field.name}},  # {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
        })
        return data

{% endfor %}
{% for msg in messages["set"]|sort %}
    ##
    # @brief Send a {{msg}} message to the device\n
    # Message description:\n
    # {{messages["set"][msg].description}}\n
    # Send the message to write the device parameters, then read the values back from the device\n
    #
{% for field in messages["set"][msg].payload %}
    # @param {{field.name}} - {% if field.units %}Units: {{field.units}}; {% endif %}{{field.description}}
{% endfor %}
    #
    # @return If verify is False, True on successful communication with the device. If verify is False, True if the new device parameters are verified to have been written correctly. False otherwise (failure to read values back or on verification failure)
    def {{msg}}(self{% for field in messages["set"][msg].payload %}, {{field.name}}{% endfor %}, verify=True):
        m = pingmessage.PingMessage(definitions.PING360_{{msg|upper}})
{% for field in messages["set"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)
        if self.request(definitions.PING360_{{msg|replace("set_", "")|upper}}) is None:
            return False
        # Read back the data and check that changes have been applied
        if (verify
{% if messages["set"][msg].payload %}
                and ({% for field in messages["set"][msg].payload %}self._{{field.name}} != {{field.name}}{{ " or " if not loop.last }}{% endfor %})):
{% endif %}
            return False
        return True  # success{% for field in messages["set"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data)

{% endfor %}

{% for msg in messages["control"]|sort %}
    def control_{{msg}}(self{% for field in messages["control"][msg].payload %}, {{field.name}}{% endfor %}):
        m = pingmessage.PingMessage(definitions.PING360_{{msg|upper}})
{% for field in messages["control"][msg].payload %}
        m.{{field.name}} = {{field.name}}
{% endfor %}
        m.pack_msg_data()
        self.write(m.msg_data) 

{% endfor %}

    def readParameters(self):
        return self.request(definitions.PING360_DEVICE_DATA)

    def transmitAngle(self, angle):
        self.control_transducer(
            self._mode,
            self._gain_setting,
            angle,
            self._transmit_duration,
            self._sample_period,
            self._transmit_frequency,
            self._number_of_samples,
            1,
            0
        )
        return self.wait_message([definitions.PING360_DEVICE_DATA, definitions.COMMON_NACK], 4.0)
    
    def transmit(self):
        return self.transmitAngle(self.angle)

{% for field in messages["control"]["transducer"].payload %}
{% if field.name != "transmit" and field.name != "reserved" %}
    def set_{{field.name}}(self, {{field.name}}):
        self.control_transducer(
{% for field2 in messages["control"]["transducer"].payload %}
{% if field2.name != "transmit" and field2.name != "reserved" %}
{% if field == field2 %}
            {{field2.name}},
{% else %}
            self._{{field2.name}},
{% endif %}
{% endif %}
{% endfor %}
            0,
            0
        )
        return self.wait_message([definitions.PING360_DEVICE_DATA, definitions.COMMON_NACK], 4.0)

{% endif %}
{% endfor %}


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Ping python library example.")
    parser.add_argument('--device', action="store", required=True, type=str, help="Ping device port.")
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate.")
    args = parser.parse_args()

    p = Ping360(args.device, args.baudrate)

    print("Initialized: %s" % p.initialize())

    print(p.readParameters())
    
    print(p.set_transmit_frequency(800))
    print(p.set_sample_period(80))
    print(p.set_number_of_samples(200))

    print(p.readParameters())


    print(p.readParameters())
    
    print(p.set_transmit_frequency(800))
    print(p.set_sample_period(80))
    print(p.set_number_of_samples(200))

    print(p.readParameters())

    for x in range(40):
        print(p.transmitAngle(x))

    print(p)
